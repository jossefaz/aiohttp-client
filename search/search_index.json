{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Async HTTP Client : Getting started Introduction When building a service oriented architecture, we often need a dedicated part of our program for external communication. This is the role of the HTTP Client. However, the relatively new way of asynchronous programming which improve dramatically the performance by giving control back to the main thread on each new single asynchronous task, force us to program in an asynchronous way along all each incoming request (if this one started as asynchronous, we must continue it, otherwise the main thread will be blocked again). This library provides a simple class that manage the HTTP communication in an asynchronous way. First Step : Import it from async_http_client import async_client_factory client = async_client_factory(host=\"example.com\", port=8080, protocol=\"https\") Second Step : Use it async def get_my_resource(dummy_id): return await client().get(f\"/{dummy_id}\") Since client is a factory, we need to call it (notice the client() syntaxe here) on every use (for further explanation, check API Reference","title":"Get start"},{"location":"index.html#async-http-client-getting-started","text":"","title":"Async HTTP Client : Getting started"},{"location":"index.html#introduction","text":"When building a service oriented architecture, we often need a dedicated part of our program for external communication. This is the role of the HTTP Client. However, the relatively new way of asynchronous programming which improve dramatically the performance by giving control back to the main thread on each new single asynchronous task, force us to program in an asynchronous way along all each incoming request (if this one started as asynchronous, we must continue it, otherwise the main thread will be blocked again). This library provides a simple class that manage the HTTP communication in an asynchronous way.","title":"Introduction"},{"location":"index.html#first-step-import-it","text":"from async_http_client import async_client_factory client = async_client_factory(host=\"example.com\", port=8080, protocol=\"https\")","title":"First Step : Import it"},{"location":"index.html#second-step-use-it","text":"async def get_my_resource(dummy_id): return await client().get(f\"/{dummy_id}\") Since client is a factory, we need to call it (notice the client() syntaxe here) on every use (for further explanation, check API Reference","title":"Second Step : Use it"},{"location":"api.html","text":"References BaseRESTAsyncClient request_id : str property writable Getter for the request id Returns: Type Description str nanoid: uid of the current request __call__ ( self , * args , ** kwargs ) special Will trow an error that avoid BaseRESTAsyncClient to be called directly and force use the get_instance class method Source code in app/base.py def __call__ ( self , * args , ** kwargs ): \"\"\" Will trow an error that avoid BaseRESTAsyncClient to be called directly and force use the get_instance class method \"\"\" raise TypeError ( \"BaseClient cannot be called directly use get_instance class method instead\" ) delete ( self , url = '' , * , params = None , headers = None , cookies = None ) async Prepare an HTTP DELETE request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' params Union[QueryParams, Mapping[str, Union[str, int, float, bool, NoneType, Sequence[Union[str, int, float, bool, NoneType]]]], List[Tuple[str, Union[str, int, float, bool, NoneType]]], Tuple[Tuple[str, Union[str, int, float, bool, NoneType]], ...], str, bytes] Query string None headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def delete ( self , url : URLTypes = \"\" , * , params : QueryParamTypes = None , headers : HeaderTypes = None , cookies : CookieTypes = None ): \"\"\"Prepare an HTTP `DELETE` request and send it asynchronously Arguments: url: Relative URL (from the base URL) params: Query string headers: HTTP Headers (Key Value) cookies: HTTP Cookies Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . delete . value , self . make_url ( url ), params = params , headers = headers , cookies = cookies ) return await self . _send_request ( request ) get ( self , url = '' , * , params = None , headers = None , cookies = None ) async Prepare an HTTP GET request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' params Union[QueryParams, Mapping[str, Union[str, int, float, bool, NoneType, Sequence[Union[str, int, float, bool, NoneType]]]], List[Tuple[str, Union[str, int, float, bool, NoneType]]], Tuple[Tuple[str, Union[str, int, float, bool, NoneType]], ...], str, bytes] Query string None headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def get ( self , url : URLTypes = \"\" , * , params : QueryParamTypes = None , headers : HeaderTypes = None , cookies : CookieTypes = None ): \"\"\"Prepare an HTTP `GET` request and send it asynchronously Arguments: url: Relative URL (from the base URL) params: Query string headers: HTTP Headers (Key Value) cookies: HTTP Cookies Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . get . value , self . make_url ( url ), params = params , headers = headers , cookies = cookies ) return await self . _send_request ( request ) get_instance ( * , host , port = None , protocol = None ) classmethod Will return a factory (as a partial function) in order to always ensure the current endpoint is selected in the endpoints registry Parameters: Name Type Description Default host str domain's host required port Optional[int] listening port None protocol Optional[str] Network Protocol (must be a value of the SupportedProtocols Enum) None Returns: Type Description partial[BaseRESTAsyncClient] partial function (BaseRESTAsyncClient factory) Examples: client = BaseRESTAsyncClient.get_instance(\"example.com\", 8080, \"https\") Source code in app/base.py @classmethod def get_instance ( cls , * , host : str , port : Optional [ int ] = None , protocol : Optional [ str ] = None ) -> \"partial[BaseRESTAsyncClient]\" : \"\"\"Will return a factory (as a partial function) in order to always ensure the current endpoint is selected in the endpoints registry Arguments: host: domain's host port: listening port protocol: Network Protocol (must be a value of the SupportedProtocols Enum) Returns: partial function (BaseRESTAsyncClient factory) Example: ```python client = BaseRESTAsyncClient.get_instance(\"example.com\", 8080, \"https\") ``` \"\"\" return partial ( BaseRESTAsyncClient , host = host , port = port , protocol = protocol ) make_url ( self , url = '' ) Url builder based on the host base url Parameters: Name Type Description Default url str relative url that will be concatenate wil the host base url '' Returns: Type Description string An absolute url including the protocol, the host base url, port (if any) and the relative url if any Source code in app/base.py def make_url ( self , url : str = \"\" ): \"\"\"Url builder based on the host base url Arguments: url: relative url that will be concatenate wil the host base url Returns: string: An absolute url including the protocol, the host base url, port (if any) and the relative url if any \"\"\" # Ensure to remove keep only one \"/\" along all the url url = re . sub ( '/+' , '/' , url ) # remove the first \"/\" at the beginning url = re . sub ( '^/' , '' , url ) return f \" { self . get_base_url () } / { url } \" patch ( self , url = '' , * , headers = None , cookies = None , data = None ) async Prepare an HTTP PATCH request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None data dict JSON, Files, Form, None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def patch ( self , url : URLTypes = \"\" , * , headers : HeaderTypes = None , cookies : CookieTypes = None , data : RequestData = None ): \"\"\"Prepare an HTTP `PATCH` request and send it asynchronously Arguments: url: Relative URL (from the base URL) headers: HTTP Headers (Key Value) cookies: HTTP Cookies data: JSON, Files, Form, Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . patch . value , self . make_url ( url ), data = data , headers = headers , cookies = cookies ) return await self . _send_request ( request ) post ( self , url = '' , * , headers = None , cookies = None , content = None , data = None , files = None ) async Prepare an HTTP POST request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None data dict JSON, Files, Form, None content Union[str, bytes, Iterable[bytes], AsyncIterable[bytes]] All contents that are NOT one of : Form encoded, Multipart files, JSON. Could be use for text or binaries None files Union[Mapping[str, Union[IO[str], IO[bytes], str, bytes, Tuple[Optional[str], Union[IO[str], IO[bytes], str, bytes]], Tuple[Optional[str], Union[IO[str], IO[bytes], str, bytes], Optional[str]]]], Sequence[Tuple[str, Union[IO[str], IO[bytes], str, bytes, Tuple[Optional[str], Union[IO[str], IO[bytes], str, bytes]], Tuple[Optional[str], Union[IO[str], IO[bytes], str, bytes], Optional[str]]]]]] Blob stream None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def post ( self , url : URLTypes = \"\" , * , headers : HeaderTypes = None , cookies : CookieTypes = None , content : RequestContent = None , data : RequestData = None , files : RequestFiles = None ): \"\"\"Prepare an HTTP `POST` request and send it asynchronously Arguments: url: Relative URL (from the base URL) headers: HTTP Headers (Key Value) cookies: HTTP Cookies data: JSON, Files, Form, content: All contents that are NOT one of : Form encoded, Multipart files, JSON. Could be use for text or binaries files: Blob stream Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . post . value , self . make_url ( url ), content = content , data = data , files = files , headers = headers , cookies = cookies ) return await self . _send_request ( request ) put ( self , url = '' , * , headers = None , cookies = None , data = None ) async Prepare an HTTP PUT request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None data dict JSON, Files, Form, None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def put ( self , url : URLTypes = \"\" , * , headers : HeaderTypes = None , cookies : CookieTypes = None , data : RequestData = None ): \"\"\"Prepare an HTTP `PUT` request and send it asynchronously Arguments: url: Relative URL (from the base URL) headers: HTTP Headers (Key Value) cookies: HTTP Cookies data: JSON, Files, Form, Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . put . value , self . make_url ( url ), data = data , headers = headers , cookies = cookies ) return await self . _send_request ( request ) EndPoint dataclass EndPoint(host: str, port: int, _protocol: str) base_url : Union [ bool , str ] property readonly Build the base url based on the protocol, the host and the port. Only host is mandatory, others will be ignored or given default value. Returns: Type Description Union[bool, str] The Base URL following this template \"{protocol}://{host}:{port}\" protocol : SupportedProtocols property readonly Get the protocol if the one that was given in constructor is supported, otherwise give the default http protocol Returns: Type Description SupportedProtocols Entry of the enum SupportedProtocols EndPointRegistry This Class is a singleton that inherits from the type class, in order to provide it as a metaclass to other classes Methods Contains a list of all supported HTTP Verbs SupportedProtocols Contains a list of all supported protocols (currently only http and https","title":"API Reference"},{"location":"api.html#references","text":"","title":"References"},{"location":"api.html#app.base.BaseRESTAsyncClient","text":"","title":"BaseRESTAsyncClient"},{"location":"api.html#app.base.BaseRESTAsyncClient.request_id","text":"Getter for the request id Returns: Type Description str nanoid: uid of the current request","title":"request_id"},{"location":"api.html#app.base.BaseRESTAsyncClient.__call__","text":"Will trow an error that avoid BaseRESTAsyncClient to be called directly and force use the get_instance class method Source code in app/base.py def __call__ ( self , * args , ** kwargs ): \"\"\" Will trow an error that avoid BaseRESTAsyncClient to be called directly and force use the get_instance class method \"\"\" raise TypeError ( \"BaseClient cannot be called directly use get_instance class method instead\" )","title":"__call__()"},{"location":"api.html#app.base.BaseRESTAsyncClient.delete","text":"Prepare an HTTP DELETE request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' params Union[QueryParams, Mapping[str, Union[str, int, float, bool, NoneType, Sequence[Union[str, int, float, bool, NoneType]]]], List[Tuple[str, Union[str, int, float, bool, NoneType]]], Tuple[Tuple[str, Union[str, int, float, bool, NoneType]], ...], str, bytes] Query string None headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def delete ( self , url : URLTypes = \"\" , * , params : QueryParamTypes = None , headers : HeaderTypes = None , cookies : CookieTypes = None ): \"\"\"Prepare an HTTP `DELETE` request and send it asynchronously Arguments: url: Relative URL (from the base URL) params: Query string headers: HTTP Headers (Key Value) cookies: HTTP Cookies Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . delete . value , self . make_url ( url ), params = params , headers = headers , cookies = cookies ) return await self . _send_request ( request )","title":"delete()"},{"location":"api.html#app.base.BaseRESTAsyncClient.get","text":"Prepare an HTTP GET request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' params Union[QueryParams, Mapping[str, Union[str, int, float, bool, NoneType, Sequence[Union[str, int, float, bool, NoneType]]]], List[Tuple[str, Union[str, int, float, bool, NoneType]]], Tuple[Tuple[str, Union[str, int, float, bool, NoneType]], ...], str, bytes] Query string None headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def get ( self , url : URLTypes = \"\" , * , params : QueryParamTypes = None , headers : HeaderTypes = None , cookies : CookieTypes = None ): \"\"\"Prepare an HTTP `GET` request and send it asynchronously Arguments: url: Relative URL (from the base URL) params: Query string headers: HTTP Headers (Key Value) cookies: HTTP Cookies Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . get . value , self . make_url ( url ), params = params , headers = headers , cookies = cookies ) return await self . _send_request ( request )","title":"get()"},{"location":"api.html#app.base.BaseRESTAsyncClient.get_instance","text":"Will return a factory (as a partial function) in order to always ensure the current endpoint is selected in the endpoints registry Parameters: Name Type Description Default host str domain's host required port Optional[int] listening port None protocol Optional[str] Network Protocol (must be a value of the SupportedProtocols Enum) None Returns: Type Description partial[BaseRESTAsyncClient] partial function (BaseRESTAsyncClient factory) Examples: client = BaseRESTAsyncClient.get_instance(\"example.com\", 8080, \"https\") Source code in app/base.py @classmethod def get_instance ( cls , * , host : str , port : Optional [ int ] = None , protocol : Optional [ str ] = None ) -> \"partial[BaseRESTAsyncClient]\" : \"\"\"Will return a factory (as a partial function) in order to always ensure the current endpoint is selected in the endpoints registry Arguments: host: domain's host port: listening port protocol: Network Protocol (must be a value of the SupportedProtocols Enum) Returns: partial function (BaseRESTAsyncClient factory) Example: ```python client = BaseRESTAsyncClient.get_instance(\"example.com\", 8080, \"https\") ``` \"\"\" return partial ( BaseRESTAsyncClient , host = host , port = port , protocol = protocol )","title":"get_instance()"},{"location":"api.html#app.base.BaseRESTAsyncClient.make_url","text":"Url builder based on the host base url Parameters: Name Type Description Default url str relative url that will be concatenate wil the host base url '' Returns: Type Description string An absolute url including the protocol, the host base url, port (if any) and the relative url if any Source code in app/base.py def make_url ( self , url : str = \"\" ): \"\"\"Url builder based on the host base url Arguments: url: relative url that will be concatenate wil the host base url Returns: string: An absolute url including the protocol, the host base url, port (if any) and the relative url if any \"\"\" # Ensure to remove keep only one \"/\" along all the url url = re . sub ( '/+' , '/' , url ) # remove the first \"/\" at the beginning url = re . sub ( '^/' , '' , url ) return f \" { self . get_base_url () } / { url } \"","title":"make_url()"},{"location":"api.html#app.base.BaseRESTAsyncClient.patch","text":"Prepare an HTTP PATCH request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None data dict JSON, Files, Form, None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def patch ( self , url : URLTypes = \"\" , * , headers : HeaderTypes = None , cookies : CookieTypes = None , data : RequestData = None ): \"\"\"Prepare an HTTP `PATCH` request and send it asynchronously Arguments: url: Relative URL (from the base URL) headers: HTTP Headers (Key Value) cookies: HTTP Cookies data: JSON, Files, Form, Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . patch . value , self . make_url ( url ), data = data , headers = headers , cookies = cookies ) return await self . _send_request ( request )","title":"patch()"},{"location":"api.html#app.base.BaseRESTAsyncClient.post","text":"Prepare an HTTP POST request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None data dict JSON, Files, Form, None content Union[str, bytes, Iterable[bytes], AsyncIterable[bytes]] All contents that are NOT one of : Form encoded, Multipart files, JSON. Could be use for text or binaries None files Union[Mapping[str, Union[IO[str], IO[bytes], str, bytes, Tuple[Optional[str], Union[IO[str], IO[bytes], str, bytes]], Tuple[Optional[str], Union[IO[str], IO[bytes], str, bytes], Optional[str]]]], Sequence[Tuple[str, Union[IO[str], IO[bytes], str, bytes, Tuple[Optional[str], Union[IO[str], IO[bytes], str, bytes]], Tuple[Optional[str], Union[IO[str], IO[bytes], str, bytes], Optional[str]]]]]] Blob stream None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def post ( self , url : URLTypes = \"\" , * , headers : HeaderTypes = None , cookies : CookieTypes = None , content : RequestContent = None , data : RequestData = None , files : RequestFiles = None ): \"\"\"Prepare an HTTP `POST` request and send it asynchronously Arguments: url: Relative URL (from the base URL) headers: HTTP Headers (Key Value) cookies: HTTP Cookies data: JSON, Files, Form, content: All contents that are NOT one of : Form encoded, Multipart files, JSON. Could be use for text or binaries files: Blob stream Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . post . value , self . make_url ( url ), content = content , data = data , files = files , headers = headers , cookies = cookies ) return await self . _send_request ( request )","title":"post()"},{"location":"api.html#app.base.BaseRESTAsyncClient.put","text":"Prepare an HTTP PUT request and send it asynchronously Parameters: Name Type Description Default url Union[URL, str] Relative URL (from the base URL) '' headers Union[Headers, Dict[str, str], Dict[bytes, bytes], Sequence[Tuple[str, str]], Sequence[Tuple[bytes, bytes]]] HTTP Headers (Key Value) None cookies Union[Cookies, http.cookiejar.CookieJar, Dict[str, str], List[Tuple[str, str]]] HTTP Cookies None data dict JSON, Files, Form, None Returns: Type Description coroutine result of the _send_request method. It need to be awaited in order to get the HTTP response Source code in app/base.py async def put ( self , url : URLTypes = \"\" , * , headers : HeaderTypes = None , cookies : CookieTypes = None , data : RequestData = None ): \"\"\"Prepare an HTTP `PUT` request and send it asynchronously Arguments: url: Relative URL (from the base URL) headers: HTTP Headers (Key Value) cookies: HTTP Cookies data: JSON, Files, Form, Returns: coroutine : result of the `_send_request` method. It need to be awaited in order to get the HTTP response \"\"\" request = Request ( Methods . put . value , self . make_url ( url ), data = data , headers = headers , cookies = cookies ) return await self . _send_request ( request )","title":"put()"},{"location":"api.html#app.base.EndPoint","text":"EndPoint(host: str, port: int, _protocol: str)","title":"EndPoint"},{"location":"api.html#app.base.EndPoint.base_url","text":"Build the base url based on the protocol, the host and the port. Only host is mandatory, others will be ignored or given default value. Returns: Type Description Union[bool, str] The Base URL following this template \"{protocol}://{host}:{port}\"","title":"base_url"},{"location":"api.html#app.base.EndPoint.protocol","text":"Get the protocol if the one that was given in constructor is supported, otherwise give the default http protocol Returns: Type Description SupportedProtocols Entry of the enum SupportedProtocols","title":"protocol"},{"location":"api.html#app.base.EndPointRegistry","text":"This Class is a singleton that inherits from the type class, in order to provide it as a metaclass to other classes","title":"EndPointRegistry"},{"location":"api.html#app.enums.Methods","text":"Contains a list of all supported HTTP Verbs","title":"Methods"},{"location":"api.html#app.enums.SupportedProtocols","text":"Contains a list of all supported protocols (currently only http and https","title":"SupportedProtocols"}]}